# YumYum Frontend Architecture Document

_This document is auto-generated by the BMad Architect agent._

---

### Section 1: Template and Framework Selection

**Content:**

Based on the project documentation and our recent setup, the project is using a modern, from-scratch frontend stack, not a pre-built starter template.

- **Framework:** Next.js (App Router)
- **Language:** TypeScript
- **UI Library:** Shadcn UI, built on Radix UI and Tailwind CSS.
- **Styling:** Tailwind CSS with CSS Variables for theming.
- **Project Structure:** A `pnpm` monorepo with the main application located in `apps/client`.

**Rationale:**

This stack was chosen for its performance, developer experience, and strong alignment with modern React development practices. Next.js provides a robust foundation with server-side rendering and static site generation capabilities. Shadcn UI offers a composable and accessible set of components that we can fully own and customize. The decision to build from scratch rather than using a template gives us maximum control over the architecture and dependencies.

---

### Section 2: Frontend Tech Stack (Revised)

**Content:**

| Category          | Technology                                                                   | Version | Purpose                                               | Rationale                                                                                                               |
| :---------------- | :--------------------------------------------------------------------------- | :------ | :---------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------- |
| Framework         | Next.js                                                                      | latest  | Core application framework                            | Provides SSR, SSG, and a great developer experience.                                                                    |
| UI Library        | React                                                                        | latest  | Building user interfaces                              | The industry standard for component-based UI.                                                                           |
| State Management  | Zustand                                                                      | latest  | Global and component state management                 | A small, fast, and scalable state-management solution with a comfortable hook-based API.                                |
| Routing           | Next.js App Router                                                           | latest  | File-based routing                                    | Built-in, intuitive, and powerful routing solution provided by Next.js.                                                 |
| Build Tool        | SWC (via Next.js)                                                            | latest  | Fast code compilation and bundling                    | Integrated into Next.js for optimal performance.                                                                        |
| Styling           | Tailwind CSS                                                                 | latest  | Utility-first CSS framework                           | Allows for rapid UI development and easy maintenance.                                                                   |
| Testing           | Jest & React Testing Library                                                 | latest  | Unit and integration testing                          | Industry-standard tools for testing React applications.                                                                 |
| Component Library | Shadcn UI, Magic UI, Aceternity UI, React Bits, PatternCraft, Unicorn Studio | latest  | Base components, advanced animations, and UI patterns | Leverages a rich ecosystem of pre-built components to accelerate development and achieve a high-quality, modern finish. |
| Form Handling     | React Hook Form                                                              | latest  | Managing form state and validation                    | Performant, flexible, and easy to use with controlled or uncontrolled components.                                       |
| Animation         | Framer Motion                                                                | latest  | UI animations and micro-interactions                  | A powerful and easy-to-use animation library for React.                                                                 |
| Dev Tools         | ESLint, Prettier                                                             | latest  | Code linting and formatting                           | Enforce code quality and consistency.                                                                                   |

**Rationale:**

This technology stack is a modern, robust, and widely-adopted choice for building performant React applications. Each tool is a leader in its category and integrates well with the others. We are prioritizing developer experience and long-term maintainability. The decision to use **Zustand** provides a lightweight yet powerful state management solution. The expanded component library selection will allow us to create a visually stunning and highly interactive user experience efficiently.

---

### Section 3: Project Structure

**Content:**

```plaintext
/apps/client/
├── public/
│   ├── fonts/
│   └── images/
└── src/
    ├── app/
    │   ├── (api)/                # API routes (e.g., for webhooks, internal tasks)
    │   ├── [vendor_slug]/        # Dynamic route for each vendor
    │   │   ├── page.tsx          # Main vendor profile page component
    │   │   └── layout.tsx        # Layout specific to the vendor page
    │   ├── globals.css           # Global styles
    │   └── layout.tsx            # Root application layout
    ├── components/
    │   ├── ui/                   # Unstyled base components from Shadcn UI
    │   ├── shared/               # Reusable components across multiple features (e.g., BrandHeader)
    │   └── features/
    │       ├── cart/             # Components specific to the shopping cart
    │       └── reel/             # Components for the full-screen reel view
    ├── lib/
    │   ├── constants.ts          # Project-wide constants, enums, and static values
    │   ├── utils.ts              # Utility functions (e.g., cn from shadcn)
    │   └── types.ts              # Core TypeScript types (Brand, Dish, etc.)
    ├── hooks/
    │   └── use-media-query.ts    # Example custom React hook
    ├── services/
    │   └── gsheets.ts            # Service for fetching and parsing data from Google Sheets
    └── store/
        └── use-cart.store.ts     # Zustand store for managing cart state
```

**Rationale:**

This structure is based on Next.js App Router best practices and is designed for scalability and maintainability.

- **`app/[vendor_slug]`:** This leverages Next.js's dynamic routing to create a unique page for each vendor based on their slug.
- **`components/`:** The directory is organized into three key areas: `ui` (for raw Shadcn components), `shared` (for components used across the entire application), and `features` (for components that are coupled to a specific feature like the cart). This separation of concerns makes the codebase easier to navigate and maintain.
- **`services/`:** This centralizes all external data fetching logic. The `gsheets.ts` file will contain all the logic for interacting with the Google Sheets backend, providing a clean, reusable interface for the rest of the application.
- **`store/`:** This is the designated location for all Zustand state management stores, ensuring a single, predictable source of truth for global state like the shopping cart.

---

### Section 4: Component Standards

#### Component Template

**Content:**

This template should be used for all new components to ensure consistency and compatibility with our `shadcn-ui` ecosystem. It includes `React.forwardRef` for compatibility and the `cn` utility for merging Tailwind CSS classes.

```typescript
import * as React from "react";

import { cn } from "@/lib/utils";

// 1. Define the component's props interface, extending standard HTML attributes.
export interface ExampleComponentProps
  extends React.HTMLAttributes<HTMLDivElement> {
  // Add component-specific props here.
  // e.g., variant?: "default" | "destructive";
}

// 2. Create the component using React.forwardRef to allow parent components to receive a ref to the underlying element.
const ExampleComponent = React.forwardRef<
  HTMLDivElement,
  ExampleComponentProps
>(({ className, ...props }, ref) => {
  // 3. Render the component's JSX.
  return (
    <div
      className={cn(
        "flex items-center justify-center p-4 border rounded-md", // 4. Base classes
        className // 5. Merge with incoming classes
      )}
      ref={ref}
      {...props}
    >
      {/* Component content goes here */}
      <p>Example Component</p>
    </div>
  );
});

// 6. Set a display name for easier debugging in React DevTools.
ExampleComponent.displayName = "ExampleComponent";

// 7. Export the component.
export { ExampleComponent };

```

#### Naming Conventions

**Content:**

- **Component Files:** `PascalCase.tsx` (e.g., `DishCard.tsx`)
- **Component Names:** `PascalCase` (e.g., `const DishCard = ...`)
- **Props Interfaces:** `[ComponentName]Props` (e.g., `DishCardProps`)
- **Hooks:** `useCamelCase.ts` (e.g., `use-cart.ts`)
- **Hook Functions:** `useCamelCase` (e.g., `export function useCart() {...}`)
- **Services:** `kebab-case.ts` (e.g., `gsheets-service.ts`)
- **State (Zustand Stores):** `use-kebab-case.store.ts` (e.g., `use-cart.store.ts`)
- **Type Definition Files:** `types.ts` or `[feature].types.ts`

**Rationale:**

These standards are critical for maintaining a clean, readable, and scalable codebase. The component template ensures that all our components are built with composition and ref forwarding in mind, which is essential for working with libraries like `shadcn-ui`. The naming conventions are standard within the React and Next.js ecosystem, making the code predictable and easy for any developer (or AI agent) to understand.

---

### Section 5: State Management (Finalized)

#### Store Structure

**Content:**

```plaintext
/src/store/
├── use-cart.store.ts       # Zustand store for managing shopping cart state.
├── use-ui.store.ts         # Zustand store for managing global UI state (e.g., open modals, reel view active).
└── types.ts                # (Optional) Shared TypeScript types used across multiple stores.
```

#### State Management Template

**Content:**

This template for `use-cart.store.ts` is now updated to use the new, stable `id` field for all operations.

```typescript
import { create } from 'zustand';
import { Dish } from '@/lib/types'; // Assuming Dish type now includes the 'id' field

// 1. Define the state and actions interfaces
interface CartItem extends Dish {
  quantity: number;
}

interface CartState {
  items: CartItem[];
  addItem: (item: Dish) => void;
  removeItem: (itemId: string) => void;
  updateItemQuantity: (itemId: string, quantity: number) => void;
  clearCart: () => void;
}

// 2. Create the Zustand store
export const useCartStore = create<CartState>((set) => ({
  // 3. Initial state
  items: [],

  // 4. Actions
  addItem: (item) =>
    set((state) => {
      const existingItem = state.items.find((i) => i.id === item.id);
      if (existingItem) {
        // If item exists, increment quantity
        return {
          items: state.items.map((i) =>
            i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i,
          ),
        };
      }
      // If item doesn't exist, add it with quantity 1
      return { items: [...state.items, { ...item, quantity: 1 }] };
    }),

  removeItem: (itemId) =>
    set((state) => ({
      items: state.items.filter((i) => i.id !== itemId),
    })),

  updateItemQuantity: (itemId, quantity) =>
    set((state) => {
      if (quantity <= 0) {
        // If quantity is 0 or less, remove the item
        return { items: state.items.filter((i) => i.id !== itemId) };
      }
      return {
        items: state.items.map((i) =>
          i.id === itemId ? { ...i, quantity } : i,
        ),
      };
    }),

  clearCart: () => set({ items: [] }),
}));

// 5. (Optional) Selectors for performance optimization
export const useCartItemCount = () =>
  useCartStore((state) => state.items.length);
export const useCartTotal = () =>
  useCartStore((state) =>
    state.items.reduce((total, item) => total + item.price * item.quantity, 0),
  );
```

**Rationale:**

This finalized approach is robust and scalable. By using a stable, system-generated `id`, we ensure that state management is reliable and free of the bugs that would have been caused by using a row index.

---

### Section 6: API Integration (Finalized)

#### Service Template

**Content:**

The architecture will feature a modular data service where each data type (`brand`, `dishes`, `status`) is handled by a dedicated function. This allows for independent caching, fetching, and error handling. The UI layer will orchestrate these services and implement the fallback logic defined in Story 1.2 of the PRD.

```typescript
import { Brand, Dish, Status } from '@/lib/types';

/**
 * NOTE: This service implements a modular "stale-while-revalidate" caching strategy.
 * Each data type is fetched and cached independently with a unique TTL.
 * The UI layer orchestrates these functions and handles the fallback display logic.
 * Full implementation details are in Story 1.2 of the PRD.
 */

// --- Brand Data Fetching ---
const BRAND_CACHE_TTL = 10 * 60 * 1000; // 10 minutes
export async function getBrandData(sheetId: string): Promise<Brand | null> {
  // 1. Check cache (key: `yumyum-brand-[sheetId]`).
  // 2. If cache hit & not expired, return cached data & revalidate in background.
  // 3. If cache miss or expired, fetch, update cache, and return fresh data.
  // 4. On error, throw.
  return null; // Placeholder for implementation
}

// --- Dishes Data Fetching ---
const DISHES_CACHE_TTL = 5 * 60 * 1000; // 5 minutes
export async function getDishesData(sheetId: string): Promise<Dish[]> {
  // 1. Check cache (key: `yumyum-dishes-[sheetId]`).
  // 2. If cache hit & not expired, return cached data & revalidate in background.
  // 3. If cache miss or expired, fetch, generate IDs, update cache, and return fresh data.
  // 4. On error, throw.
  return []; // Placeholder for implementation
}

// --- Status Data Fetching ---
const STATUS_CACHE_TTL = 2 * 60 * 1000; // 2 minutes
export async function getStatusData(sheetId: string): Promise<Status[]> {
  // 1. Check cache (key: `yumyum-status-[sheetId]`).
  // 2. If cache hit & not expired, return cached data & revalidate in background.
  // 3. If cache miss or expired, fetch, update cache, and return fresh data.
  // 4. On error, throw.
  return []; // Placeholder for implementation
}
```

#### API Client Configuration

**Content:**

```typescript
// Not applicable for this project's architecture.
```

**Rationale:**

This modular service architecture is a significant improvement. It allows for more granular control over data fetching and caching, improving efficiency. This design provides the necessary foundation for the sophisticated, multi-level offline strategy we have designed.

---

### Section 7: Routing

#### Route Configuration

**Content:**

```typescript
/**
 * Routing in Next.js (App Router) is file-system based.
 * The structure of the `src/app` directory defines the application's routes.
 */

// src/app/
// ├── [vendor_slug]/
// │   ├── page.tsx      -> (Main Route) Renders the menu for a given vendor.
// │   │                  - URL: /:vendor_slug (e.g., /the-burger-den)
// │   │
// │   └── layout.tsx    -> Layout specific to the vendor page.
// │
// ├── vendor/
// │   └── upload/
// │       └── page.tsx  -> (Utility Route) Renders the public media uploader page.
// │                      - URL: /vendor/upload
// │
// └── layout.tsx        -> The root layout for the entire application.

/**
 * --- Architectural Notes ---
 *
 * 1.  **Public Routes:** All routes in the MVP are public.
 * 2.  **Lazy Loading:** The Next.js App Router automatically code-splits and lazy-loads each route.
 * 3.  **Dynamic Routes:** The `[vendor_slug]` directory is a dynamic segment.
 */
```

**Rationale:**

This routing structure is clean, declarative, and fully leverages the power of the Next.js App Router. It establishes the core dynamic route for vendor menus and the separate utility page for the uploader.

---

### Section 8: Styling Guidelines

#### Styling Approach

**Content:**

Our styling methodology is **utility-first** using **Tailwind CSS**.

1.  **Base Components:** We will use `shadcn-ui` to provide the unstyled, accessible HTML structure.
2.  **Styling Utilities:** We will apply styles directly in the JSX using Tailwind's utility classes.
3.  **Class Merging:** The `cn` utility function will be used to conditionally apply or merge Tailwind classes.
4.  **Custom CSS:** Any truly custom CSS will be kept to a minimum and added to `src/app/globals.css`.

#### Global Theme

**Content:**

Our theme is defined using CSS Custom Properties (variables) in `src/app/globals.css`.

```css
/* src/app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Colors from front-end-spec.md */
    --background: 27 80% 94%; /* #FEF3E2 */
    --foreground: 240 10% 3.9%; /* #0B0B0B */

    --card: 0 0% 100%; /* #FFFFFF */
    --card-foreground: 240 10% 3.9%;

    --primary: 38 96% 59%; /* #FAB12F */
    --primary-foreground: 240 10% 3.9%;
    --primary-strong: 25 95% 58%; /* #FA812F */

    --secondary: 240 10% 3.9%;
    --secondary-foreground: 27 80% 94%;

    --accent: 45 100% 67%; /* #FFC857 */

    --destructive: 0 98% 40%; /* #DD0303 */
    --success: 142 71% 45%; /* #16A34A */
    --warning: 38 92% 50%; /* #F59E0B */

    --border: 0 0% 90%; /* #E6E6E6 */
    --muted: 220 9% 61%; /* #9CA3AF */
    --ring: 38 96% 59%; /* For focus rings */

    /* Sizing */
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
```

**Rationale:**

This utility-first approach with a centralized theme provides the rapid development speed of Tailwind CSS and the maintainability of a traditional design system.

---

### Section 9: Testing Requirements

#### Component Test Template

**Content:**

This template provides a standard for testing our React components using **Jest** and **React Testing Library**.

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import '@testing-library/jest-dom';
import { ExampleComponent } from '@/components/shared/ExampleComponent'; // Assuming component path

describe('ExampleComponent', () => {
  // Test 1: Basic rendering
  it('should render the component with the correct text', () => {
    render(<ExampleComponent />);
    const element = screen.getByText(/Example Component/i);
    expect(element).toBeInTheDocument();
  });

  // Test 2: Prop handling
  it('should apply the className prop correctly', () => {
    const customClass = 'my-custom-class';
    render(<ExampleComponent className={customClass} />);
    const element = screen.getByText(/Example Component/i).parentElement;
    expect(element).toHaveClass(customClass);
  });

  // Test 3: User interaction
  it('should call the onClick handler when clicked', () => {
    const handleClick = jest.fn(); // Create a mock function
    render(<ExampleComponent onClick={handleClick} />);
    const element = screen.getByText(/Example Component/i).parentElement;
    if (element) {
        fireEvent.click(element);
    }
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

#### Testing Best Practices

**Content:**

1.  **Unit Tests**: Test individual components and functions in isolation.
2.  **Integration Tests**: Test component interactions within a feature.
3.  **E2E Tests**: Test critical user flows from end-to-end (for a later stage).
4.  **Coverage Goals**: Aim for a minimum of 80% code coverage.
5.  **Test Structure**: Follow the "Arrange-Act-Assert" pattern.
6.  **Mock External Dependencies**: All external services (`gsheets.ts`) must be mocked.

**Rationale:**

This testing strategy ensures our application is robust and reliable by focusing on how users interact with the application.

---

### Section 10: Environment Configuration

**Content:**

Variables are managed in `.env.local`. Public variables are prefixed with `NEXT_PUBLIC_`.

```plaintext
# .env.local

# --- Google Sheets ---
NEXT_PUBLIC_ADMIN_SHEET_ID="your_admin_sheet_id_here"

# --- ImageKit (Multi-Account Setup) ---
NEXT_PUBLIC_IMAGEKIT_URL_ENDPOINT="your_url_endpoint"

# API credentials for the backend.
# Example for account 'ik_acc_1':
IMAGEKIT_IK_ACC_1_PRIVATE_KEY="key_for_account_1"
IMAGEKIT_IK_ACC_1_PUBLIC_KEY="secret_for_account_1"

# --- Alerting ---
LARK_WEBHOOK_URL="your_lark_webhook_url_here"
```

**Rationale:**

This configuration provides a clear and secure way to manage our project's secrets and settings, using Next.js conventions to prevent exposing server-side keys to the browser.

---

### Section 11: Frontend Developer Standards

#### Critical Coding Rules

**Content:**

1.  **Never Fetch Data Directly in Components:** Delegate all data fetching to the services in `/src/services/`.
2.  **Use Local State First:** Only use Zustand for truly global state.
3.  **Prioritize Accessibility:** Use semantic HTML and appropriate ARIA labels.
4.  **Style with Utility Classes:** Prefer Tailwind CSS over custom CSS files.
5.  **No Hardcoded Secrets:** Use environment variables for all secrets.
6.  **Strictly Typed:** Avoid using the `any` type.
7.  **Follow Naming Conventions:** Adhere to the project's established naming conventions.

#### Quick Reference

**Content:**

| Category                 | Convention / Command                                     |
| :----------------------- | :------------------------------------------------------- |
| **Run Dev Server**       | `pnpm dev`                                               |
| **Build for Prod**       | `pnpm build`                                             |
| **Run Tests**            | `pnpm test`                                              |
| **Component Naming**     | `PascalCase.tsx`                                         |
| **Hook Naming**          | `useCamelCase.ts`                                        |
| **Store Naming**         | `use-kebab-case.store.ts`                                |
| **Key Import (Styling)** | `import { cn } from '@/lib/utils';`                      |
| **Key Import (State)**   | `import { useCartStore } from '@/store/use-cart.store';` |
| **Core Data Pattern**    | Modular, "stale-while-revalidate" services.              |

**Rationale:**

These standards act as a practical "developer's guide" for the project to ensure all code is consistent, secure, and aligned with our architecture.

---
