-- MIGRATION FOR THE PRIMARY DATABASE

-- 1. RENAME `backend_type` to `datastore_type` and `gsheet_id` to `datastore_id`
-- This is done by creating a new table and copying data, as direct renames can be complex.
CREATE TABLE public.vendor_mappings_new (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vendor_slug text NOT NULL UNIQUE,
    auth_user_id uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    datastore_type text NOT NULL,
    datastore_id text NOT NULL,
    imagekit_account_id text NOT NULL,
    membership_fee real DEFAULT 0,
    membership_validity date DEFAULT (now() + '10 days'::interval),
    is_member boolean DEFAULT true,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    modify_time timestamp with time zone DEFAULT now() NOT NULL
);

-- Copy data from old table to new table
INSERT INTO public.vendor_mappings_new (id, vendor_slug, auth_user_id, datastore_type, datastore_id, imagekit_account_id, membership_fee, membership_validity, is_member, create_time)
SELECT id, vendor_slug, user_id, backend_type, COALESCE(supabase_project_id, gsheet_id), imagekit_account_id, membership_fee, membership_validity, is_member, created_at
FROM public.vendor_mappings;

-- Drop the old table and rename the new one
DROP TABLE public.vendor_mappings;
ALTER TABLE public.vendor_mappings_new RENAME TO vendor_mappings;

-- 2. CREATE a function to automatically update `modify_time`
CREATE OR REPLACE FUNCTION public.update_modify_time()
RETURNS TRIGGER AS $$
BEGIN
    NEW.modify_time = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- 3. CREATE a trigger to call the function before any update
CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.vendor_mappings
  FOR EACH ROW EXECUTE PROCEDURE public.update_modify_time();

-- 4. CREATE the new `vendor_payment` table
CREATE TABLE public.vendor_payment (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    vendor_id bigint NOT NULL REFERENCES public.vendor_mappings(id) ON DELETE CASCADE,
    payment real NOT NULL,
    payment_date date NOT NULL,
    payment_duration interval NOT NULL,
    create_time timestamp with time zone DEFAULT now() NOT NULL,
    modify_time timestamp with time zone DEFAULT now() NOT NULL
);

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.vendor_payment
  FOR EACH ROW EXECUTE PROCEDURE public.update_modify_time();

-- 5. RE-APPLY RLS policies on the new vendor_mappings table
ALTER TABLE public.vendor_mappings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Vendors can view their own mappings." ON public.vendor_mappings FOR SELECT USING (auth.uid() = auth_user_id);
CREATE POLICY "Admins can manage all mappings." ON public.vendor_mappings FOR ALL USING (true); -- Simplified for now, should be role-based

ALTER TABLE public.vendor_payment ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can manage payments." ON public.vendor_payment FOR ALL USING (true); -- Simplified for now, should be role-based
